<?php

/**
 * @file Analyzer.php
 * A basic class for analyzing parsing trees generated by Parser
 * Lang en
 * Reviewstatus: 2025-02-28
 * Localization: complete
 * Documentation: complete
 * Tests: Unit/Parser/AnalyzerTest.php
 * Coverage:
 */

namespace Sunhill\Parser\Helpers;

use Sunhill\Basic\Base;

class FunctionDescriptor extends Base
{
    
    /**
     * The name of the function
     * 
     * @var string
     */
    protected string $name;
    
    /**
     * The return type of the function
     * 
     * @var string
     */
    protected string $return_type;
    
    /**
     * An array of parameter descriptors (or empty if no parameter)
     * 
     * @var array
     */
    protected array $parameter_descriptors = [];
    
    /**
     * If true, this function can handle any count of parameters
     * 
     * @var boolean
     */
    protected bool $unlimited_parameters = false;
    
    protected string $unlimited_type = '';
    
    /**
     * With unlimited parameters there is sometimes a mimimum number of parameters
     * @var integer
     */
    protected int $mimimum_parameters = 0;
        
    public function __construct(string $name)
    {
        $this->name = $name;
    }
    
    public function getName(): string
    {
        return $this->name;    
    }
    
    public function setReturnType(string $return_type): static
    {
        $this->return_type = $return_type;
        
        return $this;
    }
    
    public function getReturnType(): string
    {
        return $this->return_type;
    }
    
    public function setUnlimitedParameters(int $minimum_count, string $type): static
    {
        $this->unlimited_parameters = true;
        $this->unlimited_type = $type;
        $this->mimimum_parameters = $minimum_count;
        
        return $this;
    }
    
    /**
     * Returns if this function supports an unlimited count of parameters (true) or not (false)
     * 
     * @return bool
     */
    public function getUnlimitedParameters(): bool
    {
        return $this->unlimited_parameters;    
    }
    
    /**
     * Returns how many unlimited parameters have there to be at least
     * 
     * @return int
     */
    public function getMinimumParameterCount(): int
    {
        return $this->mimimum_parameters;    
    }
    
    /**
     * Returns the type the unlimited parametrs have to match
     * 
     * @return string
     */
    public function getUnlimitedType(): string
    {
        return $this->unlimited_type;    
    }
    
    public function addParameter(string $type, bool $optional = false, ?string $subtype = null): static
    {
        $parameter = new \stdClass();
        $parameter->type = $type;
        $parameter->optional = $optional;
        $parameter->subtype = $subtype;
        $this->parameter_descriptors[] = $parameter;
        
        return $this;
    }
    
    /**
     * Returns the number of parameters this function need at least
     * 
     * @return int
     */
    public function getMandatoryParameterCount(): int
    {
        $count = 0;
        foreach ($this->parameter_descriptors as $parameter) {
            if (!$parameter->optional) {
                $count++;
            }
        }
        
        return $count;
    }
    
    /**
     * Returns the number of parameters this function can accept
     * 
     * @return int -1 if unlimited 
     */
    public function getTotalParameterCount(): int
    {
        if ($this->unlimited_parameters) {
            return -1;
        }
        return count($this->parameter_descriptors);
    }
}